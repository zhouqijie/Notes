# 第一部分：延迟渲染    


### 传统的渲染方法：  

在传统的基于三角形光栅化的渲染中，所有光照和着色计算都是在观察空间中的三角形片段上计算的。这样的效能较差。首先，做了许多不必要的工作。此外，为了处理含多个光源的复杂场景，我们最终会产生大量不同的着色器版本。      

> 不必要的工作例如顶点着色后再光栅化阶段才发现整个三角形会被深度测试所剔除。（Early-Z可以消除像素着色器的计算但是还不够）    

### 延迟渲染：    

*延迟渲染(deferred rendering)*是解决这些问题的另一种场景着色方法。在延迟渲染中，主要的光照计算是在屏幕空间进行的，而非观察空间。    

我们首先迅速地渲染不含光照的场景，把所有用于光照计算的信息存储在*几何缓冲(geometry buffer, G-Buffer)*中。完成场景渲染后，就用几何缓冲中的信息来计算光照和着色。这样做通常比观察空间光照更高效，又避免了着色器版本增长，而且可以相对容易地渲染一些效果。    

> Ye：一般的延迟渲染由于在每像素只能存储一组数据，因此只能渲染不透明物体。半透明物体要在延迟渲染完成后，才用传统的正向着色(forward shading)来渲染和混合。    
> Ye：视乎几何缓冲区的大小，延迟渲染可能需要较高的显存频宽。延迟渲染还需要专用的抗锯齿方法。    

> CSDN「puppet_master」：Unity中的DepthNormalTexture本身就是一个Mini GBuffer。    

### 几何缓冲(G-Buffer)：    

几何缓冲物理上是由一组缓冲实现的，但理论上它是含有丰富的光照和表面信息的单个缓冲。    

几何缓冲一般包括但不限于：  
1. 深度。  
2. 法向量。  
3. 漫反射颜色。  
4. 预计算辐射传输。  
5. 屏幕空间运动矢量(动态模糊使用)。  
6. 镜面强度。  


(End)






