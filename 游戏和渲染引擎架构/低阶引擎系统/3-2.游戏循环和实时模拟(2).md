# 第六部分：多处理器的游戏循环    

## 一、多处理器游戏机架构    

XBOX360和PS3都是多处理器游戏机。  

> XBOX360有三个完全相同的PowerPC处理器核。每个核有专门的L缓存，三个核共用一个L2缓存。三个核和GPU共用一个统一的512mb内存这些内存可以用来放可执行代码、应用数据、纹理、显存等。    

> PS3和XBOX架构不一样，PS3不采用三个相同处理器，而是提供不同种类的处理器，也不采用统一内存架构(UMA)，而是把内存分为多个区块。主处理器称为PPU，六个副处理器称为SPU。GPU有专用的256mb显存，PPU则能存取256mb系统内存，SPU不能直接存取主内存数据，要使用直接内存访问(DMA)控制器来回复制主内存和SPU局部存储的数据块。    


## 二、SIMD  

> SIMD指令集的指令能让一个指令同时执行于多个数据之上，是一种细粒度形式的硬件并行。  

> 把现有的三维数学代码改为支持SIMD会有点棘手。但如果使用的是封装的数学库而不是在代码里直接写运算过程，那么转换至SIMD的工作会容易很多。    

## 三、分叉和会和    

另一种利用多处理器硬件的方法是采用分叉-会和法。基本原理是把一个单位的工作分割成更小的子单位分配到多个分叉，最后等所有工作完成后再合并汇合。    

> 分叉-汇合法产生的游戏循环架构和单线程游戏循环架构很相似，但是几个主要阶段都能并行化。  

> 分叉-汇合法可以用于动画混合/骨骼混合等场景。    

## 四、每个子系统运行于独立线程    

另一个多任务方法是把每个子系统置于独立线程上运行，主线程负责控制和同步这些子系统并执行游戏主循环。    

> 此设计适合那些需要重复执行隔离性功能的某些子系统。    

## 五、作业模型    

> 把每个子系统运行于独立线程的架构问题是工作量粒度较粗，会限制处理器利用率。    

为了充分利用并行硬件架构，另一种方法是让引擎把工作分割成多个粒度细小和独立的作业(job)，作业准备就绪后就可以加入队列，待有闲置处理器就从队列取出执行。    

> 作业模型能最大化处理器利用率，相比子系统运行于独立线程的设计，可以减少或者消除对主线程的一些限制。    






