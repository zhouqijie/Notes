# 运行时游戏性基础系统    

> 多数游戏引擎都会带有一套运行时游戏性基础系统。这套系统位于游戏和的游戏引擎分界线附近，是分界线之上还是分界线之下，不同的引擎有不同的模式。    

#### 多数引擎都会提供一些主要子系统：    

1. *运行时游戏对象模型(runtime gameobject model)*：抽象游戏对象模型的实现，供设计师在编辑器使用。    
2. *关卡管理和串流(level management and streaming)*：负责载入及释放关卡。许多引擎在运行时把关卡数据串流至内存从而实现巨大无缝世界。    
3. *更新实时对象模型(real-time object model updating)*：定期更新每个对象以令世界中的游戏对象能有自主的行为。    
4. *消息和事件处理(messaging and event handling)*：用于对象间通信。对象间的*消息*许多时候是用来发出世界状态改变的信号的，所以一般又称为*事件*。    
5. *脚本(scripting)*：游戏引擎通常会整合一个脚本语言，用于编写高级游戏逻辑。    
6. *目标和流程管理(objective and game flow)*：常见于故事驱动的游戏。负责管理游戏整体流程，通常是玩家目标构成的序列/树/图。目标又常以章节(chapter)的方式分组。（游戏流程管理系统会追踪玩家目标的完成进度，并在目标未完成之前阻挡玩家进入另一区域）      



#### 这些主要系统之中，运行时对象模型可能是最复杂的。它通常要提供以下大部分功能：    

1. 唯一对象标识符：典型的游戏世界包含很多不同类型的游戏对象。在运行时必须能识别或找到想要的对象。所以每个对象需要一个唯一识别符，可以使用高效的整数标识符或者方便的字符串标识符，但通常使用字符串散列标识符，因为它性能如同整数标识符又能转换成字符串。    
2. 游戏对象查询：游戏性基础系统必须提供一些方法搜寻游戏对象。例如希望通过唯一标识符获取某个对象，或者希望取得某类型所有对象，以及其他高级查询。    
3. 游戏对象引用：当找到了需要的对象，需要以某种机制长期或者短期保留其引用。对象引用可能简单使用一个指针，也可能使用更高级的智能指针或者句柄。    
4. 动态生成和摧毁游戏对象：游戏世界中的动态对象通常要随游戏性创建和销毁。许多引擎会提供一个系统，为动态产生的游戏对象管理内存及相关资源。    
5. 联系底层引擎系统：例如有些对象包含可渲染的三角形网格，有些对象有动画，有些对象有碰撞或者物理信息。    
6. 实时模拟对象行为：游戏引起需要随时间更动态地更新所有游戏对象的状态。    
7. 网络复制：网络多人游戏中，多个机器通过网络连接。某个对象的状态通常是由其中一台机器所拥有和管理，然而对象的状态也必须复制(通信)至其他参与的机器，使所有玩家所见一致。      
8. 存档和载入：许多游戏引擎能存储和读取游戏对象的当前状态。需要一些编程语言的功能例如RTTI、反射、抽象构造等。    
9. 其他可能的功能：定义新游戏对象模型、有限状态机。（Cre：对于组件化游戏对象可能不是必要的）      



