# UNITY的脚本系统猜测    

## 脚本实现机制：  

1. 底层由C++实现。  
2. 底层把函数暴露给Mono供脚本内部调用。  
3. 定义Behavior基类，所有脚本对象都继承自它。  
4. 脚本发生改变则重新编译和载入。  

## MonoBehaviour相关：  

关于构造函数：
- Unity不建议在构造函数中初始化游戏对象。因为编辑器在编辑模式中会自动调用构造函数，用于索回默认变量值。  
- 构造函数除了在编译后等意想不到的地方调用，还会被不活动的对象和预制体调用。  
- 建议只在继承派生脚本时使用构造函数。

关于Awake和Start：
Awake在被Instantiate时调用，而Start在被Instantiate完成后调用。

## 程序集结构：  

UnityEngine.dll   --声明Internal Call接口  

Assembly-CSharp.dll --编写的脚本  

## 编辑器界面：

- 编辑器界面：C++实现？？  
- Inspector面板：反射特性实现。  






<br />
<br />
<br />
<br />



# 为什么使用C#脚本系统    

<br />
<br />

## C#作为脚本相对C++的优势    

### 反射    

- **属性反射**      

这个是非常有用的一个特性. 在做编辑器时跟PropertyGrid结合后, 基本上一个面板搞定所有的参数设置, 可以参考Unity的Inspector面板. 程序可以专注于程序逻辑, 不用在UI上花太多的精力.    

放到脚本里也一样, 逻辑属性的扩充就是加一个成员变量, 策划也不用去配什么表了, 直接所见即所得的编辑实体属性, 还不怕填错, 来回折腾
通过方法名字进行调用.    

这可以改变一下编程的思路, 比如发送一个消息到一个对象, 你有叫这个名字的处理函数就执行, 没有就算了, 我通知完我就不管了。    

- **能过类名创建对象**    

相当于内置了工厂模式, 比较状态机中, 状态的扩充就不用麻烦再去改原有的代码了。    


> Cre：C++也能实现RTTI、属性反射、序列化、工厂模式等。但是非常复杂。可以参考《游戏引擎原理与实践》。    



### 序列化    

C++在文件保存方面如果不做好设计, 就会面临各种版本兼容问题. C#的序列化是默认就支持的, 我们再也不用去操心数据是保存成ChunkData还是BinaryXML什么的, 直接一个Serialize搞定。    

还有一个比较有用的地方, 就是Save/Load, 比如脚本改了, 先Save, 重新载入脚本, 再Load, 就完成了运行时的更新, 见下面的"热更新"。    

### 异常处理    

C++虽然有异常处理, 但是很少有人用, 因为它本身就不完善. 把主要的程序逻辑放入脚本后, 相当于运行在一个沙盒里, 做好异常处理可以保证程序不崩溃。    

### 垃圾回收    

C++写出的代码安全性与稳定性非常依赖程序员的素质, 而脚本可以让你不用关心内存越界, 内存泄露, 非法内存访问等这种隐藏很深的BUG, 节省大量精力去专注于游戏逻辑。    

### 热更新    

脚本可以在游戏运行过程中修改, 再重新载入, 游戏会继续按照新的逻辑运行. 这相对于C++的结束->修改->编译->重新运行->还原到指定场合, 可以节省大量的时间。    
另一方面就是方面调试, 因为可以实时更改运行逻辑, 那很多时间相关的逻辑代码就可以方便的屏蔽, 修改, 输出等。    

### 协程(Coroutine)    

C++里没有这东西, 要改变编程的思维方式需要一段时间的适应, 具体可以参考这篇文章: 用C#中的yield实现Coroutine框架。    
虽然只是语言级别的特性, 实际上并没有改变什么, 但是在做AI/技能什么的写出来的代码能简化太多了!    


<br />
<br />

## 补充：热更新：  

1. 热更新的基本原理：检测到脚本的DLL发生改变就重新载入。（Unity把脚本都编译成dll文件，虽然dotNet支持直接把代码直接转换成可运行的文件）
2. Mono是以domain为单位load/unload的, 所以要为脚本运行创建一个单独的domain。
3. 脚本的domain卸载前, dll是不可写的, 这是由于mono做了file mapping. 解决办法有两个: 一是从内存加载, 二是先卸载再编译。
4. 加载后需要还原卸载前的对象状态, 这可以通过序列化来实现。
5. C#的编译时间基本上可以忽略, 游戏运行时这边脚本一改, 卡个几帧就可以继续用新的脚本继续跑了。


<br />
<br />

## 参考原文：C#脚本实践    

（一）C#脚本实践：https://blog.csdn.net/xoyojank/article/details/6038664  
（二）Unity脚本机制分析：https://blog.csdn.net/xoyojank/article/details/6041310  
（三）集成到游戏：https://blog.csdn.net/xoyojank/article/details/6979135    
（四）反射与序列化：https://blog.csdn.net/xoyojank/article/details/7015001    
（五）调试器：https://blog.csdn.net/xoyojank/article/details/7039982    
（六）脚本相对C++的优势：https://blog.csdn.net/xoyojank/article/details/7185128    


（END）    