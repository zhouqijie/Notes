# 请求分段虚拟存储管理    

<br />
<br />

## 1、基本原理    

请求分段的基本思想是：将用户程序的所有段首先存放在辅助存储器中，当用户程序被调度投入运行时，首先把当前需要的一段或者几段装入内存，在执行过程中访问到不在内存的段时再把他们从外存装入。    

- 段表设计：    

段表在段式存储管理的基础上需要着呢该相应的字段，其段表包括段号、段长、存取权限、在内存中起始位置、在外存中的起始位置、是否在内存、修改标志、共享标志和扩充位等。    

- 访问段：    

如果需要访问某段时，查段表，若该段在内存中，则按段式存储管理进行地址转换得到绝对地址；如果该段不在内存中，则硬件发出一个缺段中断，操作系统处理这个中断时，先查找内存分配表，找出一个足够大的连续区域容纳该；如果找不到足够大连续区域则检查空闲区总和，总和能满足要求则进行适当的移动再将该段装入；如果总和仍然不够，则可调入一个或几个分段再辅助存储器上，再将该段装入内存。    

- 扩充：    

有些数据段大小会随输入数据多少而变化。这就需要在该分段末尾添加新信息，但添加后的段总长度应不超过硬件允许的最大段长。    
对于这种变化的数据段，越界中断处理会判断该段的“扩充位”，如果可以扩充就增加段的长度，如果不能扩充，这个越界中断就表示出错。    


<br />
<br />

## 2、段的共享和保护    


### 共享段表：    

为了实现段的分享，除了原有的进程段表外，还要在系统中建立一张段共享表，每个共享分段占一个表项，每个表项含两部分内容。      
第一部分包含共享段名、段长，内存起始地址，状态位，辅存地址、共享进程个数计数器。    
第二部分包含共享该段的所有进程名、状态、段号、存取控制位（通常为只读）。    

### 段的共享：    

1. 当出现第一个要使用某个共享段的进程时，操作系统为此共享段分配一块内存，再将共享段装入该区。    
2. 同时将共享段在内存的起始地址填入共享段表中对应项的内存始址处，共享进程个数加一，修改状态位为1，填写使用该共享段的进程有关信息（进程名、使用共享段的段号、存取控制等）。而进程段表中共享段的表项事项内存共享段表地址。    
3. 此后，当又有进程要使用该共享段时，仅需直接填写共享段表和进程段表，以及吧共享进程个数加一即可。    
4. 当进程不再使用共享段时，应手动释放该共享段，除了在共享段表中删去进程占用项外，还要把共享进程个数减一。    
5. 共享进程个数计数器为0时，说明已没有进程使用该共享段了，系统需要回收该共享段的内存，并把占用表项也取消。    

> 这样做的优点是：不同进程可以用不同段号使用同一个共享段；由于进程段表中共享段的表项指向内存共享段表地址，所以，每当共享段被移动、调出、或再装入时，只需要修改共享段表的项目。不必修改共享该段的每个进程的段表。    

### 存储保护：    

由于每个分段再逻辑上是独立的，所以实现存储保护也方便。    

- ⭕越界检查：    

在段表寄存器中存放了段长信息，在进程段表中存放了每个段的段长。在存储访问时，首先把指令逻辑地址的段号与段表长度对比，如果段号大于等于段表长度，则发出地址越界中断；其次还需要检查段内地址是否大于段长，如果大于将产生地址越界中断，从而确保每个进程只在自己的地址空间运行。      

- ⭕存取控制检查：    

在段表的每个表项中，均设有存取控制字段，用于规定此段的访问方式，通常设置的访问方式有：只读、读写、只执行等。    



<br />
<br />

## 3、请求段页式虚拟存储管理    

请求段页式虚拟存储管理，实在在段页式的基础上增加了用于实现虚拟存储的缺页中断机制、缺段中断机制来实现的。    

与传统的段页式存储管理一样，用户的逻辑地址空间划分为段号、段内页号、页内偏移。但是，请求段页式管理并没有一个将作业的所有段在作业运行前全部装入内存，只是部分分段装入内存，因此还需要有作业表来记载进入内存的作业段情况。    

作业表中记录了进入系统中的所有作业及该作业的段表起始地址等信息。段表中至少包括该段是否在内存、该段页表的起始地址等信息，页表中包括该页是否在内存、对应的物理块号等。    

请求段页式虚拟存储管理的动态地址转换击购由段表、页表、快表构成。在地址转换过程中如果所访问的段内页在内存中，则对其处理与段页式存储管理的情况相同。如果不能从内存段表中查询出所需要的段，则表示该段不存在内存，系统发出请求调段中断信号；如果段表中存在该段信息，但是没有所在的页面信息，则表示该页不在内存，系统发出请求调页中断信号。    

同样如果发出请求调段和请求调页后，如果没有内存，则需要在内存和外存之间进行置换。置换算法思想和页面置换算法思想类似。    


（END）    


    
