# 类和结构成员      


## 成员种类    

1. 字段。（数据成员）  
2. 常量。（编译器使用真实值替代）  
3. 方法。（与特定类关联的函数）  
4. 属性。（可以从客户端访问的函数组，访问方式和字段一样）  
5. 构造函数和析构函数。  
6. 索引器。（允许以下标访问对象）  
7. 运算符。  
8. 事件。  
9. 类型。（类型可以包含内部类）    


## 方法和函数的区别    

正式的C#术语区分函数和方法。在C#术语中，*“函数成员”*不仅包含**方法**，也包含另一些非数据成员，如**索引器**、**运算符**、**构造函数和析构函数**等。    


## 只读成员  

如果不希望在初始化之后修改数值，就可以使用`readonly`关键字。只读字段只能在构造函数中分配值。    

## 不可变类型    

如果类型包含可以改变的成员，他就是一个可变类型。使用readonly修饰符，编译器就会在状态改变时报错。  

如果没有任何可改变成员，只有只读成员，他就是一个不可变类型。    

不可变类型的一个例子就是String类。    

> CRE：可以简单理解为"可变"的传染性。  


<br />
<br />
<br />
<br />



# 结构    

1. 结构是值类型，而不是引用类型。  
2. 结构的生存周期与简单的数据类型一样。  
3. 结构不支持继承。  
4. 结构字段一般声明为public。(而类一般声明为private)      

## 内存布局    

使用结构，可以指定字段如何在内存中布局。（CRE：这点类似C/C++）  

## 结构的new操作符  

结构的new操作符并不分配堆中的内存，仅代表调用构造函数。所以很多时候可以省略`new`初始化。  

## 结构的性能优化    

结构是值类型，存储在栈中，所以分配内存和释放内存时性能非常好，速度非常快。    

但是对于比较大的结构，应该尽量避免结构的复制，多使用`ref`关键字传参数。  

## 继承    

结构不是为继承设计的，不能为结构提供其他基类，每个结构都派生自`System.ValueType`类型。System.ValueType没有给System.Object添加任何新成员，而是提供了一些更适合结构的实现方式。    




<br />
<br />
<br />
<br />


# 方法    


## 方法声明    

```C#  
public int Add(int num1, int num2)
{
    return num1 + num2;
}
```

## 表达式体方法    

```C#  
public int Add(int num1, int num2) => (num1 + num2);
```

## 方法的重载    

方法的几个版本有不同的签名，即方法名相同，但参数的个数或类型不同。    

## 命名参数    

调用方法时，可以使用参数名加冒号指定。（`Foo(num1: 1, num2:2)`）    


## 可选参数    

参数是可选的。必须为可选参数提供默认值。（`public int Foo(int num1 = 0, int num2 = 0)...`）    


## 个数可变的参数    

声明数组类型的参数，并添加`params`关键字，就可以使用任意数量的参数调用该方法。    


## 扩展方法    

要扩展一个类，为它添加新的功能，除了继承外还可以可以使用扩展方法。    

扩展方法定义为静态，但是语法是实例方法。定义时添加`this`来修饰第一个参数，调用时像普通实例方法那样调用。      




<br />
<br />
<br />
<br />



# 构造函数    

声明构造函数的方法就是声明一个和类名相同而且没有返回值的方法。    

可以不提供任何构造函数，编译器会自动生成一个默认构造函数，他把所有成员字段初始化为默认值。  

构造函数可以重载。但是**如果提供了带参数构造函数，编译器就不会再生成默认构造函数**。    


## 从构造函数中调用其他构造函数    

一个类中有几个构造函数。使用一个C#特殊语法即**构造函数初始化器**可以实现构造函数的互相调用。    

```C#
public Car(string description, uint wheels)
{}
public Car(string description) : this(description, 4)
{}
```
还可以调用基类的构造函数，需要用`base`而非`this`关键字：    
```C#  
public Car(string description) : base()
{}
```



## 静态构造函数    

C#的一个新特性是可以编写无参数的静态构造函数。这种构造函数只执行一次。    

.NET运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻执行的代码放在静态构造函数中。    




<br />
<br />
<br />
<br />



# 属性    

*属性(property)*的概念：它是一个方法或者一对方法，在客户端代码看来，它们是一个字段。    

## 自动实现的属性    

如果`get`和`set`中没有任何逻辑，就可以使用自动实现的属性。这种属性会自动实现后备成员变量。    

使用自动实现的属性，就不能直接访问字段，因为不知道编译器生成的名称。    

在较新的C#版本中，自动实现的属性可以使用属性初始化器来初始化：    
`public int Age{get;set;} = 42;`    



## 属性的访问修饰符    

C#允许给get和set访问器设置不同的访问修饰符：`public string Name{get; private set;}`    


（END）  