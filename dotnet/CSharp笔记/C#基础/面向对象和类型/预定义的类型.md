# 预定义的类型    



## 值类型和引用类型    

- 区别：  

值类型直接存储其值，而引用类型存储对值的引用。    

- 内存位置：  

值类型存储在堆栈中。而引用类型存储在托管堆中。    

- 举例：  

在C#中，基本数据类型都是值类型。    
类(class)都是引用类型。  
结构(struct)都是值类型。    


## .NET类型    

数据类型的C#关键字(比如`int`、`string`等)从编译器映射到.NET数据类型。例如声明一个int类型的数据时，声明的实际是`System.Int32`结构体的一个实例。这样的意义是：表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。    

例如，要把基本数据类型转换为string类型，可以使用`.ToString()`方法。    
> CRE：还可以给基本数据类型编写一些便捷的扩展方法。      
> CRE：C++的基本数据类型转字符串需要一堆重载函数`to_string()`，调用也不方便。    

这种语法机制仍然把数据存储为基本类型，所以肯定没有性能损失。    


## 内置的值类型        

- 整型    

|名称|.NET类型|说明|  
|-|-|-|  
|`sbyte`|`System.SByte`|8位有符号整数|  
|`short`|`System.Int16`|16位有符号整数|  
|`int`|`System.Int32`|32位有符号整数|  
|`long`|`System.Int64`|64位有符号整数|  
|`byte`|`System.Byte`|8位无符号整数|  
|`ushort`|`System.UInt16`|16位无符号整数|  
|`uint`|`System.UInt32`|32位无符号整数|  
|`ulong`|`System.UInt64`|64位无符号整数|  

> C#中所有数据类型都以平台无关的方式定义。例如C#中`int`总是32位的，而在C++中位数取决于平台。    
> C#的`byte`是0~255的标准8位类型。C#认为`byte`和`char`是完全不同的类型，它们之间的编程转换必须显式请求。    
> 所有整数类型都能被赋予十进制或者十六进制的值，后者需要`0x`前缀。（CRE：二进制需要`0b`前缀）    


- 浮点数类型    

|名称|.NET类型|说明|  
|-|-|-|  
|`float`|`System.Single`|32位单精度浮点数|  
|`double`|`System.Double`|64位双精度浮点数|  

> 代码中的非整数硬编码被编译器默认为双精度。单精度需要加上`f`或者`F`后缀。    

- decimal类型    

decimal类型表示精度更高的浮点数。其.NET类型`System.Decimal`，位数为28位。    

> 要指定为decimal类型，需要加上`M`或者`m`后缀。    


- 布尔类型  

C#的`bool`类型.NET类型为`System.Boolean`。    

> bool和整型不能互相隐式转换。不能用0和非0表示true和false。    


- 字符类型    

C#`char`类型支持Unicode。可以用十六进制数表示，也可以用转义序列表示。    


## 内置的引用类型        


- object类型    

在C#中，`object`就是所有所有类型的最终基类。所有内置类型和用户类型都从它派生。    
object可以用来引用任何类型的对象，例如用object类型可以把值类型*装箱*移动到堆中。        
object实现了许多通用用途的基本方法，比如ToString、Equals、GetHashCode等。    


- string类型    

C#有`string`关键字，.NET类型为`System.String`，有了它，像字符串连接和复制这类操作就很简单了。      

string是引用类型，所以把字符串变量赋给另一个字符串时，会得到对内存中同一字符串的两个引用。但是string和一般的引用类型有一点区别，比如它的值是不可改变的，修改一个字符串会创建一个全新的string对象。其他指向原字符串的字符串变量不发生变化。    


可以在字符串前面加上`@`，表示所有字符都不视为转义。    

C#6还可以在字符串前面加上`$`，实现字符串插值。（CRE：以前是使用`String.Format(...)`）      



（END）  
