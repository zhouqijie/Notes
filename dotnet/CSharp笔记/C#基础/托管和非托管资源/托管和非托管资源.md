# 资源    

托管和非托管资源，即存储在托管堆和本地堆中的对象。    

尽管GC释放存储在托管堆中的对象，但是不释放本地堆中的对象，必须手动释放。    


<br />
<br />
<br />
<br />

# 后台内存管理    

## 值类型  

Windows使用一个虚拟寻址系统，该系统把程序可用的内存地址映射到硬件内存的实际地址，这些任务由完全由Windows在后台管理。    

32位处理器上每个进程都可以使用4GB的内存，无论计算机实际有多少物理内存。这个4GB内存实际上包含了程序的所有部分，包括可执行代码，加载的DLL，以及运行时所使用的所有变量的内容。这个4GB的内存称为虚拟内存地址，以下简称为内存。   

在虚拟内存中，有一个区域称为栈。栈存储非对象成员的值数据类型。（CRE：为什么使用栈，因为变量的生命周期，即分配和释放，和栈的入栈出栈一样）    

## 引用类型    

栈的性能很高，但是不够灵活。对于所有引用类型，就要使用托管堆。    

托管堆和C++使用的堆不同，他在垃圾回收器的控制下工作，与传统堆相比有很大优势。    

只要保持对数据的引用，该数据就肯定存在于堆上。    


## 垃圾回收    

托管堆的工作方式非常类似栈，对象会在内存中一个挨一个防止，这样就很容易使用指向下一个空闲存储单元的指针来确定下一个对象的位置。    

CRE：在内存上删除对象，会形成内存碎片。这样要找足够大的内存块在存储每个对象就很麻烦。    

垃圾回收器如果释放了能释放的所有对象，就会把其他对象移动回堆的顶部，再次形成一个连续的内存块。因此，托管堆可以继续像栈那样确定在什么地方存储新对象。当然，在移动对象时，这些对象的所有引用都需要用正确的新地址在跟想，但垃圾回收器会处理更新问题。    

垃圾回收器的这个压缩操作是托管堆和非托管的堆的区别所在。使用托管的堆，只需要读取堆指针的值即可，而不需要遍历地址链表来查找地方放置新数据。    

> 一般情况下，垃圾回收器会在运行时确定需要进行垃圾回收时运行。也可以调用GC.Collect()方法强制运行垃圾回收器。    



<br />
<br />
<br />
<br />

（END）  
