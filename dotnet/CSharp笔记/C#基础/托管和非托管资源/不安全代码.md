# 不安全代码    

> C#使用对象引用和垃圾回收机制，对开发人员隐藏了大部分内存管理，但是有时候选哟直接访问内存。    


## 用指针直接访问内存    

指针并不是新东西，**C#的引用就是一个类型安全的指针**，指针只是一个以与引用相同的方式存储地址的变量，其区别是C#不允许直接访问在引用变量中包含的地址。    

这种低级的内存访问也是有代价的。指针使用起来比较困难，需要非常高的编程技巧和很强的能力，仔细考虑代码所完成的逻辑操作，才能成功地使用指针。    


- **使用`unsafe`关键字编写不安全代码**    

C#只允许在特别标记的代码块使用指针。任何方法都可标记为unsafe，这种方法允许把指针用作参数。还可以把类或结构标记为unsafe，这表示假设所有成员都是不安全的。    


- **指针的声明**    

`int* numPtr;`    
`byte*[] arrPtr;`    


- **`*`运算符和`&`运算符**    

`&`表示“取地址”。（也称为“寻址”运算符）      
`*`表示获取地址的内容。（也成为“解引用”或者“解析”运算符）    


- **指针和整型的转换**    

在32位系统上，一个地址占用4个字节，把指针强制转化为除了uint、long、ulong之外的数据类型肯定会导致溢出错误（int也可能导致溢出错误）。如果创建64位应用程序，就需要把指针强制转换为ulong类型。    

- **指针类型之间的转换和void指针**  

可以在指向不同类型的指针之间进行显式转换。    

C#中使用void指针的情况不多，特殊情况下如果使用对void指针解引用，编译器就会标记为错误。    

- **指针的算术运算和sizeof运算符**        

可以对指针使用+、-、++、--、+=、-=运算符，这些运算符的右边必须是long或者ulong类型。  

> 假定有一个float指针，在其值上加上1，编译器就会假定我们要查找float后面的存储单元，因此会给该值加上4个字符，即一个float占用的字节数。如果是double类型指针，加1就代表指针的值加上8个字符，即1个double占用的字节数。      

如果需要在代码中使用某种数据类型的大小，可以使用`sizeof`运算符，返回该类型占用的字节数。使用sizeof的优点是不必在代码中硬编码数据类型的大小，使得代码移植性更强。    


- **结构指针和成员访问运算符`->`**    

结构体指针的工作方式和预定义值类型指针一样，但是有一个条件，即**结构不能包含任何引用类型**。    

成员访问运算符：  
```C#  
vecPtr->x = 4.0;
vecPtr->y = 4.0;
```  

- **类成员指针和`fixed`关键字**    

可以对类的值类型成员取地址，但是由于垃圾回收过程中，垃圾回收器会把对象移动到内存另一位置，所以有时对成员的指针会指向错误的内存地址。解决办法是使用`fixed`关键字，他会告诉垃圾回收器这些对象不能移动。    

```C#  
fixed (long* ptr = &(obj.X))
{
    //....
}
```


- **`stackalloc`栈内存分配**    

```C#  
double* ptr = stackalloc double[20];
*ptr = 1.0;
*(ptr + 1) = 2.0;
*(ptr + 2) = 3.0;
//或者  
ptr[0] = 1.0;
ptr[1] = 2.0;
ptr[2] = 3.0;
```  




（END）    