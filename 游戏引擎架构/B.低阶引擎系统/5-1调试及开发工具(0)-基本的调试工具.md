# 一、日志和追踪    

打印语句是非常强大的调试工具。很多情况下有些bug不适合使用断点和监视窗口来跟踪，这时可以使用打印语句的调试方法。    

> 在linux和win32运行C/C++编写的控制台应用程序，就可以使用`printf()`或者`iostream`的接口往stdout打印。    
> 如果是win32窗口应用程序，没有控制台，就不能使用`printf()`或者`iostream`了。但是在VisualStudio中调试时可以使用win32函数`OutputDebugString()`向VisualStudio的调试控制台打印。    

<br />
<br />

## 冗长级别(verbosity level)：  

多数引擎会提供一些机制来控制冗长级别。冗长级别设置为很小的值时，只有严重错误才会打印，提高冗长级别则更多打印语句会做输出。  


<br />
<br />

## 频道(channel)：  

把调试输出分类为频道是另一个极其有用的功能。想要查看某一类输出信息时就可以过滤掉其他输出。    

<br />
<br />

## 把输出同时抄写至日志文件：  

把所有调试信息抄写至文件，就可以在事后诊断问题。最好把所有输出都写进日志文件。    

- 是否每次调用输出函数后都对日志文件flush?  

 1. 游戏崩溃时日志文件仍然会包含最后的输出。  
 2. 可能会需要很高的成本。  

所以只有日志量不多或者确实必要时可以使用flush。  


<br />
<br />

## 崩溃报告：  

多数操作系统都可以设置一个顶层异常处理函数(top-level exception handler)，此函数能捕获大部分崩溃情形。你可以在这个函数内打印各种有用信息。  


<br />
<br />
<br />
<br />

# 二、调试用绘图功能    

大部分游戏引擎都会提供一组调试绘图的API，可以绘制有颜色的线条、简单图形、三维文本等，以便在调试期间做可视化。在发布版本会将这些移除。 

这些绘图功能可以让游戏逻辑和数学问题更加直观地显现，能节省开发人员大量的时间。    

#### 调试绘图API：  

> CRE:Unity中有DebugDraw以及GizmosDraw等功能。    

调试绘图API应该满足的功能：  
1. 简单易用。  
2. 应该支持绘制一些图元。（直线、球体、坐标轴、包围盒、格式化文本等）  
3. 应该支持一些绘图可选参数。（颜色、是否深度测试、线的宽度、球体半径等）    
4. 应该支持把图元绘制至世界空间。  
5. 应该可以在代码里的任何地方调用API。  
6. 每个调试图元都应该包含其生命周期。（如果一个调试绘制代码每帧都会执行，那么周期应该设为1帧）  
7. 应该能高效地处理大量图元。（不至于在绘制大量图元时过于卡顿）  

> 多数高速渲染引擎都会要求用一个场景数据结构管理所有视觉元素，使得引擎能高效地渲染。（参考渲染引擎相关内容）  


<br />
<br />
<br />
<br />

# 三、游戏内置菜单    

能在游戏进行中配置各种设置，而非每次都重新编译链接，可以大幅缩减开发周期。  

最简便方法就是游戏内置菜单，可以用来设置全局变量的值或者调用一些函数。  

> 游戏内置菜单开启时一般会把游戏暂停。  

<br />
<br />
<br />
<br />

# 四、游戏内置控制台    

有些引擎会提供控制台。有的取代游戏内菜单，有的和菜单并存。  

控制台功能比游戏内置菜单更加强大。控制台可以提供一些命令。使开发人员能监视和操控全局引擎设置以及执行各种命令。    

<br />
<br />
<br />
<br />

# 五、调试用相机以及游戏暂停    

一个重要的调试功能是游戏暂停时仍然可以控制摄像机。实现此功能的方法是暂停游戏逻辑的时钟，但仍保持执行渲染引擎。    

<br />
<br />
<br />
<br />

# 六、作弊    

另一个重要的调试功能是作弊，在测试游戏性时，此功能极为有用，否则会花大量时间去玩游戏。    

> 激活作弊通常是通过作弊码(cheat code)。  

<br />
<br />
<br />
<br />

# 七、截图和录像    

> 实现屏幕截图一般是通过图像API把帧缓冲传由显存传送至主内存。  
> 有些引擎提供全面的录像模式。这些系统以游戏目标帧率获取屏幕截图，通常这些屏幕截图会离线处理生成AVI/MP4格式的视频文件。  


（END）    